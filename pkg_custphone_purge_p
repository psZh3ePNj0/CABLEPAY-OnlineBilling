CREATE OR REPLACE PACKAGE  archive_customer.pkg_custphone_archivepurge_p  AS

    /**************************VERSION CONTROL LOG*****************************
    *
    * DATE             	JIRA  			SNOW         	WHO              Comments
    * June/July-2023 	INFRA-13799	      				CCARTWRIGHT      CUSTOMER PHONE 
	*																	+ Dependent Archiving - Phase 1
	*
    ***************************VERSION CONTROL LOG******************************/
	


    /******************************************************************************
    *
    *  Title:        pr_ready_to_process_cust_phone_archive_tabs
    *  Schema Owner: ARCHIVE_CUSTOMER 
    *  Created:      August 2023
    *  Author:       Christophe Cartwright
    *
    *  Description:	 	Toggles <READY_TO_PROCCESS> column customer_phone_archive table.
	*					This essentially controls which / when tables  
	*					are archived / purged. 
    *
    *  
    *  Modifications:
    *  Date        Who               Description
    *  	
    ******************************************************************************/

	PROCEDURE pr_ready_to_process_cust_phone_tabs(p_table_list IN VARCHAR2, p_ready_to_process IN VARCHAR2,p_result OUT NUMBER);

	
	
    /******************************************************************************
    *
    *  Title:        pr_depopulate_phone_archive_tabs
    *  Schema Owner: ARCHIVE_CUSTOMER 
    *  Created:      August 2023
    *  Author:       Christophe Cartwright
    *
    *  Description:	 	Dynamically Purges Data from CUSTOMPER_PHONE_01 and Dependent Tables  
	*					once backed up to the respective archived tables and schemas.  
	*					Purge based on ARCHIVE_CUSTOMER.customer_phone_archive and ARCHIVE_PURGE_PROCESS_LOG tables 	
    *
    *  
    *  Modifications:
    *  Date        Who               Description
    *  	
    ******************************************************************************/

    PROCEDURE pr_depopulate_phone_archive_tabs(p_lower_bound_date IN VARCHAR2,p_upper_bound_range IN NUMBER,p_level in NUMBER,p_user in VARCHAR2,p_group_name IN VARCHAR2,
	p_base_table in VARCHAR2,p_timestamp_stop_lowerbound IN VARCHAR2,p_timestamp_stop_upperbound IN VARCHAR2,p_table_list IN VARCHAR2,p_result OUT NUMBER);


	
END;
/


/***************************************************************************************************
**************************** END OF PACKAGE DEFINITION *********************************************
****************************************************************************************************/



CREATE OR REPLACE PACKAGE BODY archive_customer.pkg_custphone_archivepurge_p AS


    /******************************************************************************
    *
    *  Title:        pr_ready_to_process_cust_phone_tabs
    *  Schema Owner: ARCHIVE_CUSTOMER 
    *  Created:      August 2023
    *  Author:       Christophe Cartwright
    *
    *  Description:	 	Toggles <READY_TO_PROCCESS> column customer_phone_archive table.
	*					This essentially controls which / when tables  
	*					are archived / purged. 
    *
    *  
    *  Modifications:
    *  Date        Who               Description
    *  	
    ******************************************************************************/



	
    PROCEDURE pr_ready_to_process_cust_phone_tabs(p_table_list IN VARCHAR2,p_ready_to_process IN VARCHAR2, p_result OUT NUMBER)
	as 
		--local variable
				
		l_ready_to_process		varchar2(3):='YES';
		l_unready_to_process	varchar2(3):='NO';		

		l_error					varchar2(1024);
	
		
	
BEGIN	

	
			-------------------------------------------------------------------
			
		if (p_ready_to_process ='YES') and (p_table_list='CUSTOMER_PHONE_01') THEN 
			
					update 		archive_customer.customer_phone_archive 	
					set			ready_to_process=l_ready_to_process
					where       dba_constraints_table_name IN (p_table_list);				
					
					update 		archive_customer.customer_phone_archive 	
					set			ready_to_process=l_unready_to_process
					where       dba_constraints_table_name NOT IN (p_table_list);
									
					commit;
					p_result:=1;				



		elsif (p_ready_to_process ='YES') and (p_table_list='CUSTOMER_PHONE_DISPOSITION_02') THEN 
			
					update 		archive_customer.customer_phone_archive 	
					set			ready_to_process=l_ready_to_process
					where       dba_constraints_table_name IN (p_table_list);				
					
					update 		archive_customer.customer_phone_archive 	
					set			ready_to_process=l_unready_to_process
					where       dba_constraints_table_name NOT IN (p_table_list);
									
					commit;
					p_result:=1;	
					
					

		elsif (p_ready_to_process ='YES') and (p_table_list='OTHERS_CUSTOMER_PHONE') THEN 
			
					update 		archive_customer.customer_phone_archive 	
					set			ready_to_process=l_ready_to_process
					where       base_table = 'CUSTOMER_PHONE_01'
					and 		dba_constraints_table_name in ('REFERRAL','CUSTOMER_PHONE_SOURCE');	
								
					
					update 		archive_customer.customer_phone_archive 	
					set			ready_to_process=l_unready_to_process
					where       base_table = 'CUSTOMER_PHONE_01'
					and 		dba_constraints_table_name NOT in ('REFERRAL','CUSTOMER_PHONE_SOURCE');
									
					commit;
					p_result:=1;				



							

			--TASK Fisished or something is amiss - turn off all Table Processing
		elsif (p_ready_to_process ='NO') THEN 	
			
					update 		archive_customer.customer_phone_archive 	
					set			ready_to_process=l_unready_to_process;
								
					commit;
					p_result:=1;				

	
			--Safeguard case - turn off all Table Processing
		else 			
					update 		archive_customer.customer_phone_archive 	
					set			ready_to_process=l_unready_to_process;
								
					commit;
					p_result:=1;	

					
		end if;
			
			-------------------------------------------------------------------
			
			
		EXCEPTION 
		WHEN OTHERS then

			l_error:=SUBSTR(SQLERRM,1,1024);
			
				update 		archive_customer.customer_phone_archive 	
				set			ready_to_process=l_unready_to_process;
				
				commit;
				p_result:=0;
		
		END pr_ready_to_process_cust_phone_tabs;
		
		
	


    /******************************************************************************
    *
    *  Title:        pr_depopulate_phone_archive_tabs
    *  Schema Owner: ARCHIVE_CUSTOMER 
    *  Created:      August 2023
    *  Author:       Christophe Cartwright
    *
    *  Description:	 	Dynamically Purges Data from CUSTOMPER_PHONE_01 and Dependent Tables  
	*					once backed up to the respective archived tables and schemas.  
	*					Purge based on ARCHIVE_CUSTOMER.customer_phone_archive and ARCHIVE_PURGE_PROCESS_LOG tables 	
    *
    *  
    *  Modifications:
    *  Date        Who               Description
    *  	
    ******************************************************************************/
	

    PROCEDURE pr_depopulate_phone_archive_tabs(p_lower_bound_date IN VARCHAR2,p_upper_bound_range IN NUMBER,p_level in NUMBER,p_user in VARCHAR2,p_group_name IN VARCHAR2,
	p_base_table in VARCHAR2,p_timestamp_stop_lowerbound IN VARCHAR2,p_timestamp_stop_upperbound IN VARCHAR2,p_table_list IN VARCHAR2, p_result OUT NUMBER)
	as


		
		--User Defined Record (UDRs) 
		
		type cust_phone_record_number is record (
			r_cust_phone_dependents			rowid,
			r_cust_phone_dependents_pkn		number
		);
		


		type cust_phone_record_varchar is record (
			r_cust_phone_dependents			rowid,
			r_cust_phone_dependents_pkv		varchar2(512)
		);
		

		
		--Finally Collection Types of the Above UDRs
		type c_cust_phone_number is table of cust_phone_record_number;
		l_c_cust_phone_number  c_cust_phone_number;
	


		type c_cust_phone_varchar is table of cust_phone_record_varchar;
		l_c_cust_phone_varchar  c_cust_phone_varchar;
		
		
		
					------------------
					
		type cur_typ is ref cursor;
		c_data cur_typ; 
		c_data_lookup cur_typ;
		


					------------------		
					
		l_timestamp_stop_lowerbound      varchar2(24):= p_timestamp_stop_lowerbound;
		l_timestamp_stop_upperbound      varchar2(24):= p_timestamp_stop_upperbound;
		l_timestamp_stop_current      	varchar2(24);


		l_child_table_name		varchar2(200);
		l_child_table_owner   	varchar2(100);
		l_child_col_name			varchar2(100); 
		l_child_constraints_name	varchar2(100); 
		l_child_constraints_pk_column_name		varchar2(256);
		l_parent_col_name			varchar2(100);  
		l_parent_table_name		varchar2(100);
		l_parent_table_owner   	varchar2(100);  
		l_process_name		   	varchar2(100);    
		l_weight   				NUMBER; 
		min_weight   				NUMBER;
		l_cons_level				NUMBER;
		l_has_been_archived		varchar2(3);		

		l_result				NUMBER;
        l_limit   				NUMBER:=10000;
					
		
		l_activity				varchar2(16):='PURGE';
		l_archive_prefix			varchar2(10):='ARCHIVE_';  
		l_archive_suffix			varchar2(10):='_LOOKUP';		
		l_inactive_accounts		varchar2(32):='INACTIVE_ACCOUNTS';
		
		l_ddl_cursor					varchar2(2000);	
		l_ddl_cursor_lookup				varchar2(2000);

		l_ddl							varchar2(2000);	
		l_ddl_lookup					varchar2(2000);

		
		l_lower_bound_date 				DATE;
		l_lower_bound_date_static 		DATE:=to_date(p_lower_bound_date,'mm/dd/rr');
		l_upper_bound_range  			NUMBER:=p_upper_bound_range;	
		l_upper_bound_date 				DATE;
		
		
		l_archpurge_proclog_status      	varchar2(16); 
		l_archpurge_proclog_msg      		varchar2(1024);  
		l_archpurge_proclog_rundate 		DATE;
		l_archpurge_proclog_rowcnt      	NUMBER(22) := 0;
		l_rowcnt      						NUMBER(22) := 0;
		l_rowcnt_lookup      				NUMBER(22) := 0;

		l_rows_processed   				number(22):=0;
		l_rows_processed_lookup   		number(22):=0;
 
		l_ready_to_process_result		number(22);

 
		l_file      						utl_file.file_type;
		l_file_name 						VARCHAR2(100);	
		l_file_name1 						VARCHAR2(100);		
		l_dir						varchar2(30):='CUST_PHONE_ARCHIVE_DIR';
			
		l_error							varchar2(1024);
		
		


		--CURSOR 		Cur_Get_Tab_Recs  used as driving table for Archiving and Purging.
		
		-- NOTE LISTAGG Function needed for tables with composite index. The REPLACE, | and  'a.' features are required FOR
		-- for dba_constraints_pk_column_name column (composite fileds separated by ','.   The 'a.' is used further in the 
		--SP where join between operational table and lookup table encountered <<ORA-00918: column ambigously defined>>
		
		CURSOR 		Cur_Get_Tab_Recs IS
		select      distinct(dba_constraints_table_name),
					dba_constraints_table_owner, 
					nvl(dba_constraints_constraints_name,'N/A') dba_constraints_constraints_name,
					dba_constraints_column_name, 
					dba_cons_columns_column_name, 
					dba_cons_columns_table_name,
					dba_cons_columns_owner,
					dba_cons_weight,
					dba_cons_level,
                    LISTAGG(trim(REPLACE('a.'||dba_constraints_pk_column_name,',' , '||''|''||a.')), ',') WITHIN GROUP (ORDER BY dba_constraints_pk_column_name) dba_constraints_pk_column_name						
		from        archive_customer.customer_phone_archive
		where       dba_cons_level = p_level
		and 		ready_to_process='YES'
		and 		base_table = p_base_table
		group by    dba_constraints_table_name,dba_constraints_table_owner, dba_constraints_constraints_name,
 					dba_constraints_column_name, dba_cons_columns_column_name, dba_cons_columns_table_name,
					dba_cons_columns_owner,dba_cons_weight,dba_cons_level 					
		order by   1 desc,2,4 desc;


		
		BEGIN

			--Initial Loop Value: Set to 1 (successful). If no rows at level this will be output and decrement to next level.
			--Critical otherwise we will loop forever.  If Issues encountered - this value will change.
			l_result:=1;

	
			EXECUTE IMMEDIATE 'ALTER SESSION SET NLS_DATE_FORMAT = '||'''mm/dd/rr''';
			EXECUTE IMMEDIATE 'ALTER SESSION ENABLE PARALLEL DML';
	
			
			<<loop_cur_get_tab_recs>>
			FOR f_Get_Tab_Recs IN Cur_Get_Tab_Recs
			LOOP

				
				l_child_table_name:= f_Get_Tab_Recs.dba_constraints_table_name;		
				l_child_table_owner:= f_Get_Tab_Recs.dba_constraints_table_owner;
				l_child_constraints_name:= f_Get_Tab_Recs.dba_constraints_constraints_name;
				l_child_col_name:= f_Get_Tab_Recs.dba_constraints_column_name;
				l_parent_col_name:= f_Get_Tab_Recs.dba_cons_columns_column_name;
				l_parent_table_name:= f_Get_Tab_Recs.dba_cons_columns_table_name;
				l_parent_table_owner:= f_Get_Tab_Recs.dba_cons_columns_owner;
				l_weight:=f_Get_Tab_Recs.dba_cons_weight;
				l_cons_level:= f_Get_Tab_Recs.dba_cons_level;
				--l_child_constraints_pk:=f_Get_Tab_Recs.dba_constraints_pk;								
				l_child_constraints_pk_column_name:=f_Get_Tab_Recs.dba_constraints_pk_column_name;				
				
				l_process_name:=l_child_table_name;
		
				-----------------------------------


						
	
				-- Check ARCHIVE_PURGE_PROCESS_LOG for this table to ensure no other PROCESS for target table IS ALREADY RUNNING
				--Exit Archiving PROCESS for target table will as we dont want to impact operations.
		
				-- Check ARCHIVE_PURGE_PROCESS_LOG to ensure no other ARCHIVE PROCESS IS ALREADY RUNNING
		
				select 	count(*) 
				into 	l_archpurge_proclog_rowcnt 
				from 	archive_purge_process_log
				where   upper (process_name) = upper (l_process_name)
				and 	upper(activity) = upper(l_activity)
				and 	status = 'RUNNING';



				if (l_archpurge_proclog_rowcnt > 0) THEN 
					l_result:=0;	-- Process Failed - EXIT  OUTTERMOST LOOP <<loop_cur_get_tab_recs>>
					EXIT loop_cur_get_tab_recs;	
				end if;											
		
				
				--========================================================================================================================================--
		
				select      min(dba_cons_weight)
				into 		min_weight
				from        archive_customer.customer_phone_archive
				where       dba_constraints_table_name = l_child_table_name
				and 		dba_constraints_table_owner = l_child_table_owner
				and 		dba_cons_level = l_cons_level;
				
		
				if (l_weight <> min_weight) THEN 
					l_result:=1;
					CONTINUE;		--CONTINE in OUTTERMOST LOOP <<loop_cur_get_tab_recs>>
				end if;
				
				--========================================================================================================================================--
				
				--Reset LowerBound Date for each Loop Pass
				l_lower_bound_date:=l_lower_bound_date_static;
				
				l_archpurge_proclog_status:='RUNNING';
				l_archpurge_proclog_rowcnt:=0;
				l_archpurge_proclog_msg:='Initiating PURGE for Table: '||l_child_table_owner||'.'||l_child_table_name;
				
				pkg_tuc_archivepurge.pr_initialise_archivepurge_dates(l_process_name, 
												l_activity,
												p_user,
												p_group_name,												
												l_archpurge_proclog_status,
												l_archpurge_proclog_rowcnt,
												l_archpurge_proclog_msg,
												l_lower_bound_date, 
												l_upper_bound_range, 
												l_upper_bound_date);
					
			
			
				--If l_lower_bound_date <> p_lower_bound_date --exit 
				--l_lower_bound_date is an IN OUT variable to pr_initialise_archivepurge_dates which would change if TABLE
				--process has been archived. In that case either:
						--p_lower_bound_date > l_lower_bound_date : Incoming Requested Date Higher than what is purged => so there is a GAP.
						--p_lower_bound_date < l_lower_bound_date : Incoming Requested Date lower than what is purged => data requested is already purged
		
				if (l_lower_bound_date <> p_lower_bound_date) THEN 
				
					l_archpurge_proclog_status:='ERROR';
					l_archpurge_proclog_rowcnt:=0;
					l_archpurge_proclog_msg:='Please check date input / format carefully. Requested date is either before recent PURGED date, so its been purged, or after recent PURGED date, so there is DATA in between not purged.';
					l_upper_bound_date:=sysdate;	--set this to current time for time of error
					
		
					pkg_tuc_archivepurge.pr_initialise_archivepurge_dates(l_process_name, 
													l_activity,
													p_user,
													p_group_name,													
													l_archpurge_proclog_status,
													l_archpurge_proclog_rowcnt,
													l_archpurge_proclog_msg,
													l_lower_bound_date, 
													l_upper_bound_range, 
													l_upper_bound_date);
				
					l_result:=-888;		-- Process Date format suspect - CONTINE in OUTTERMOST LOOP <<loop_cur_get_tab_recs>>
					CONTINUE;			--  to next table until there are no more tables
					
					
				
				end if;
				--========================================================================================================================================--
		 
				
				if (l_archpurge_proclog_rowcnt = 0)  and (min_weight = l_weight)  and (l_lower_bound_date = p_lower_bound_date) THEN
				
					BEGIN 

						--------------------------------------------------
						-- Reset l_rows_processed + l_rows_processed_lookup for the next incoming table 													
						l_rows_processed   		:=0;
						l_rows_processed_lookup :=0;	



						-- Get Total Records Remaining to Purge from LOOKUP table Prior to job Start for the input period
						-- If Job completes prior to 5am - exit out gracefully. Else exit out with STOPPED status and 
						--job will pick up again during next run. <l_rowcnt_lookup>  use will be seen in the <BULK COLLECT>
						--logic further on below.


						--l_ddl_lookup:=	'SELECT COUNT(*) '
						--				||' FROM '||l_archive_prefix||l_child_table_owner||'.'||l_child_table_name||l_archive_suffix
						--				||' WHERE start_date >= to_date('''||l_lower_bound_date||''',''mm/dd/rr'')' 
						--				||' AND end_date < to_date('''||l_upper_bound_date||''',''mm/dd/rr'')';
						

						--EXECUTE IMMEDIATE (l_ddl_lookup);								
						--l_rowcnt_lookup:=SQL%ROWCOUNT;
								
						
						-------------------------------------------------------------------------------------------------------
						SELECT  l_child_table_owner||'_'||l_child_table_name||'-PURGE-'||TO_CHAR(SYSDATE, 'yyyymmdd-hh24mi')||'.log' INTO l_file_name FROM DUAL;
						--------------------------------------------------------------------------------------------------------
							
						l_file := UTL_FILE.fopen (l_dir, l_file_name, 'a',32767);
						UTL_FILE.put_line(l_file, '===============================================================================================');
						UTL_FILE.put_line(l_file, l_child_table_owner||'.'||l_child_table_name||' PURGE PROCESS RUN START: '|| to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'));
						UTL_FILE.put_line(l_file, l_rowcnt_lookup);
						UTL_FILE.put_line(l_file, '===============================================================================================');
						UTL_FILE.new_line(l_file,2);
						UTL_FILE.fclose (l_file);
	


						-- Key Portion and Reasoning for Lookup Tables. LookUp Tables has subset of columns from ARCHIVE tables 
						-- also when purge of original Prod tables is successful - the LookUp table entry will be removed as well
						-- in order to streamline the lookup table and improve Purge performance.


						l_ddl_cursor:= 	'SELECT /*+parallel (a 12)*/ a.rowid,'||l_child_constraints_pk_column_name
										||' FROM '||l_child_table_owner
										||'.'||l_child_table_name||' a, '||l_archive_prefix||l_child_table_owner
										||'.'||l_child_table_name||l_archive_suffix||' c' 
										||' WHERE '||l_child_constraints_pk_column_name||' = c.primary_key';


								
						l_file := UTL_FILE.fopen (l_dir, l_file_name, 'a',32767);
						UTL_FILE.new_line(l_file,1);	
						UTL_FILE.put_line(l_file, '===============================================================================================');
						UTL_FILE.put_line(l_file,l_ddl_cursor);
						UTL_FILE.put_line(l_file, '===============================================================================================');		
						UTL_FILE.new_line(l_file,2);
						UTL_FILE.fclose (l_file);
	



						OPEN c_data for l_ddl_cursor;
						<<loop_c_data>>
							LOOP
	
	
								--Time Loop Check. If we are outside of Job Interval:
								--Update tuc_archive table with DATE 
								--Update archive_purge_process_log table, but with special note that Process was STOPPED 							
								--Update Log File but with special note that Process was STOPPED
								--gracefully exit with with special exit code. 
								
								SELECT to_char(sysdate,'HH24:MI:SS') INTO l_timestamp_stop_current FROM dual;
		
									
		
								--------------------------------------------------------------------						
								IF (l_timestamp_stop_current > l_timestamp_stop_lowerbound)  
								AND (l_timestamp_stop_current < l_timestamp_stop_upperbound) THEN
								--------------------------------------------------------------------
		
										--Time Loop Check. If we are outside of Job Interval (9pm -5am):
										--[i]	Update tuc_archive table with DATE 
										--[ii] 	Update archive_purge_process_log table, but with special note that Process was STOPPED 							
										--[iii]	Update Log File but with special note that Process was STOPPED
										--[iv] 	Call SP <PR_READY_TO_PROCESS_TUC_ARCHIVE_TABS> to disable Readiness of Purge. 
										-- [v]	gracefully exit with with special exit code = 1
		
										
										update 		archive_customer.customer_phone_archive
										set 		has_been_purged='YES',
													purged_to=to_date(l_upper_bound_date,'mm/dd/rr')
										where       dba_constraints_table_name = l_child_table_name
										and 		dba_constraints_table_owner = l_child_table_owner
										and 		dba_cons_level = l_cons_level;
										
										commit;
												
										--------------------------------------------------	
						
														
										l_archpurge_proclog_status:='STOPPED';
										--archpurge_proclog_rowcnt:=l_rowcnt;
										l_archpurge_proclog_msg:='PROCESS '||l_process_name|| ' STOPPED as Daily Job interval (9pm-5am) reached.';
			
										pkg_tuc_archivepurge.pr_update_archivepurge_dates(l_process_name,
																			l_activity,
																			p_user,																				
																			l_lower_bound_date, 
																			l_upper_bound_date,
																			l_archpurge_proclog_status,
																			l_archpurge_proclog_rowcnt,
																			l_archpurge_proclog_msg);
																			
										--------------------------------------------------
													
							
										l_file := UTL_FILE.fopen (l_dir, l_file_name, 'a',32767);
										UTL_FILE.new_line(l_file,1);	
										UTL_FILE.put_line(l_file, '===============================================================================================');
										UTL_FILE.put_line(l_file, l_child_table_owner||'.'||l_child_table_name||' PROCESS RUN STOPPED: JOB INTERVAL REACHED '|| to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'));
										UTL_FILE.put_line(l_file, '===============================================================================================');	
										UTL_FILE.new_line(l_file,2);
										UTL_FILE.fclose (l_file);
										
										--------------------------------------------------	
										pr_ready_to_process_cust_phone_tabs(p_table_list,'NO', l_ready_to_process_result);
										
										--------------------------------------------------	
										
										l_result:=-999;	
										EXIT loop_cur_get_tab_recs; 		--Process Failed - EXIT  OUTTER LOOP <<loop_cur_get_tab_recs> 


								-----------------------------------------------------------------------						
								END IF;
								------------------------------------------------------------------------
	
		
	
								if (l_child_table_name IN ('CUSTOMER_PHONE_01','CUSTOMER_PHONE_DISPOSITION_02','CUSTOMER_PHONE_SOURCE','REFERRAL','T_PHONE_CHANNEL_REQUEST',
								'T_QC_CUSTOMER_PHONE_CT','T_PHONE_CHANNEL_TRANSACTION_GROUPING')
								) THEN
			
									FETCH c_data
									BULK COLLECT INTO l_c_cust_phone_number LIMIT l_limit;
										
										forall i in l_c_cust_phone_number.first .. l_c_cust_phone_number.last															
										EXECUTE IMMEDIATE 'delete from '||l_child_table_owner||'.'||l_child_table_name||' f where f.rowid = :1' 
										USING l_c_cust_phone_number(i).r_cust_phone_dependents;
	
	
										--forall i in l_c_cust_phone_number.first .. l_c_cust_phone_number.last
										--EXECUTE IMMEDIATE 'delete from '||l_archive_prefix||l_child_table_owner||'.'||l_child_table_name||l_archive_suffix
										--||' g where g.primary_key = :1' USING l_c_cust_phone_number(i).r_cust_phone_dependents_pkn;
	
	
										l_rows_processed:= l_rows_processed + l_c_cust_phone_number.count;	
										l_archpurge_proclog_rowcnt:=l_rows_processed;
										l_file := UTL_FILE.fopen (l_dir, l_file_name, 'a',32767);
										UTL_FILE.put_line(l_file, l_child_constraints_pk_column_name||' PROCESSED | '  || l_rows_processed ||' | Date:'|| to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'));
										UTL_FILE.put_line(l_file, l_child_constraints_pk_column_name||'LOOKUP PROCESSED | '  || l_rows_processed ||' | Date:'|| to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'));
										UTL_FILE.put_line(l_file, '===============================================================================================');
										UTL_FILE.fclose (l_file);
										
									EXIT loop_c_data WHEN c_data%NOTFOUND;   --EXIT  INNER LOOP <<loop_c_data>>.  Still in OUTTER LOOP <<loop_cur_get_tab_recs>								
									COMMIT;											
	

				
								------------------------------------------------------------------------

								else

									FETCH c_data
									BULK COLLECT INTO l_c_cust_phone_varchar LIMIT l_limit;
										forall i in l_c_cust_phone_varchar.first .. l_c_cust_phone_varchar.last															
										EXECUTE IMMEDIATE 'delete from '||l_child_table_owner||'.'||l_child_table_name||' f where f.rowid = :1' 
										USING l_c_cust_phone_varchar(i).r_cust_phone_dependents;
	
	
										--forall i in l_c_notify_varchar.first .. l_c_notify_varchar.last
										--EXECUTE IMMEDIATE 'delete from '||l_archive_prefix||l_child_table_owner||'.'||l_child_table_name||l_archive_suffix
										--||' g where g.primary_key = :1' USING l_c_t_uc_varchar(i).r_t_uc_dependents_pkv;
	
	
										l_rows_processed:= l_rows_processed + l_c_cust_phone_varchar.count;	
										l_archpurge_proclog_rowcnt:=l_rows_processed;
										l_file := UTL_FILE.fopen (l_dir, l_file_name, 'a');
										UTL_FILE.put_line(l_file, l_child_constraints_pk_column_name||' PROCESSED | '  || l_rows_processed ||' | Date:'|| to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'));
										UTL_FILE.put_line(l_file, l_child_constraints_pk_column_name||'LOOKUP PROCESSED | '  || l_rows_processed ||' | Date:'|| to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'));
										UTL_FILE.put_line(l_file, '===============================================================================================');
										UTL_FILE.fclose (l_file);	

									EXIT loop_c_data WHEN c_data%NOTFOUND;   --EXIT  INNER LOOP <<loop_c_data>>.  Still in OUTTER LOOP <<loop_cur_get_tab_recs>
									COMMIT;	
									
								------------------------------------------------------------------------
								
								end if;
								
								------------------------------------------------------------------------							
				
																		
						END LOOP loop_c_data;
							
						CLOSE c_data;
						
					--------------------------------------------------------------------------------------------------------


						-- Update ARCHIVE_PURGE_PROCESS_LOG with completion time and Rows successfully Processed (Archive and Purge)
						
						l_file := UTL_FILE.fopen (l_dir, l_file_name, 'a',32767);
						UTL_FILE.new_line(l_file,1);	
						UTL_FILE.put_line(l_file, '===============================================================================================');
						UTL_FILE.put_line(l_file, l_child_table_owner||'.'||l_child_table_name||' PROCESS RUN END: '|| to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'));
						UTL_FILE.put_line(l_file, '===============================================================================================');	
						UTL_FILE.new_line(l_file,2);
						UTL_FILE.fclose (l_file);

				
						--------------------------------------------------			
						--Update notify.tuc_archive Table Process Entry with Successful Archive Info 
						
						
						update 		archive_customer.customer_phone_archive
						set 		has_been_purged='YES',
									purged_to=l_upper_bound_date
						where       dba_constraints_table_name = l_child_table_name
						and 		dba_constraints_table_owner = l_child_table_owner
						and 		dba_cons_level = l_cons_level;
						
						commit;						
						--------------------------------------------------	
								
						--Update archive_purge_process_log Table Process Entry with Successful Archive Info 
		
						l_archpurge_proclog_status:='COMPLETED';
						--l_archpurge_proclog_rowcnt:=l_rowcnt;
						l_archpurge_proclog_msg:='Purge Process Successful.';
								
								
								pkg_tuc_archivepurge.pr_update_archivepurge_dates(l_process_name,
															l_activity,
															p_user,																
															l_lower_bound_date, 
															l_upper_bound_date,
															l_archpurge_proclog_status,
															l_archpurge_proclog_rowcnt,
															l_archpurge_proclog_msg);
															
						l_result:=1;
						continue;	-- CONTINE in OUTTERMOST LOOP <<loop_cur_get_tab_recs>>	to next table until there are no more tables						
		


					-------------------------------------------------------------				
					EXCEPTION
						WHEN OTHERS
						THEN
						
								--We have reach here where Process Failed. 
								-- [i] 		Gather errors to spool to log FILE,
								-- [ii] 	update archivepurge
								-- [iii] 	Call SP <PR_READY_TO_PROCESS_TUC_ARCHIVE_TABS> to disable Readiness of Purge. 
								-- [iv]		Exit SP with failure code = 0
								
								l_error:= SUBSTR(SQLERRM,1,1024);
								l_upper_bound_date:=to_date(sysdate,'mm/dd/rr');	--set this to current time for time of error
							
														
								l_file := UTL_FILE.fopen (l_dir, l_file_name, 'a',32767);
								UTL_FILE.put_line(l_file, '===============================================================================================');
								UTL_FILE.put_line(l_file, l_ddl);
								UTL_FILE.put_line(l_file, l_error);
								UTL_FILE.new_line(l_file,1);
								UTL_FILE.put_line(l_file, '===============================================================================================');
								UTL_FILE.put_line(l_file, l_child_table_owner||'.'||l_child_table_name||' PURGE PROCESS RUN END: '|| to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'));
								UTL_FILE.put_line(l_file, '===============================================================================================');
								UTL_FILE.new_line(l_file,1);
								UTL_FILE.fclose (l_file);
		
								
								------------------------------------------------------------------------------------------------------------------	
				
								l_archpurge_proclog_status:='ERROR';
								l_archpurge_proclog_rowcnt:=0;
								l_archpurge_proclog_msg:=l_error;
								
								
								pkg_tuc_archivepurge.pr_update_archivepurge_dates(l_process_name,
															l_activity,
															p_user,
															l_lower_bound_date, 
															l_upper_bound_date,
															l_archpurge_proclog_status,
															l_archpurge_proclog_rowcnt,
															l_archpurge_proclog_msg);
															
								------------------------------------------------------------------------------------------------------------------				


								pr_ready_to_process_cust_phone_tabs(p_table_list,'NO', l_ready_to_process_result);
										
								l_result:=0;				-- Process Failed - Exit OUTTER LOOP <<loop_cur_get_tab_recs>>
								exit loop_cur_get_tab_recs;

								------------------------------------------------------------------------------------------------------------------						
					END;
		
		
				--========================================================================================================================================--

		
				else 

					--We have reach here where Process did not meeet expected conditions - as a failsafe
					--	[i]		Call SP <PR_READY_TO_PROCESS_TUC_ARCHIVE_TABS> to disable Readiness of Purge. 
					--	[ii]	Exit SP with failure code = 0
					------------------------------------------------------------------------------------------------------------------
					pr_ready_to_process_cust_phone_tabs(p_table_list,'NO', l_ready_to_process_result);
							
					l_result:=0;	-- Process Failed - Exit OUTTER LOOP <<loop_cur_get_tab_recs>>
					exit loop_cur_get_tab_recs; 

				
				--========================================================================================================================================--
				
				end if;
				
				--========================================================================================================================================--
							
			END LOOP loop_cur_get_tab_recs;

			p_result:=l_result;	

		
		EXCEPTION 
			WHEN OTHERS THEN
		
						l_error:= SUBSTR(SQLERRM,1,1024);		
						-------------------------------------------------------------------------------------------------------
						SELECT  'CKC-ERROR'||TO_CHAR(SYSDATE, 'yyyymmdd-hh24mi')||'.log' INTO l_file_name1 FROM DUAL;
						--------------------------------------------------------------------------------------------------------

						l_file := UTL_FILE.fopen (l_dir, l_file_name1, 'a',32767);
						UTL_FILE.put_line(l_file, '===============================================================================================');
						UTL_FILE.put_line(l_file, 'l_error:' ||l_error);
						UTL_FILE.put_line(l_file, '===============================================================================================');
						UTL_FILE.new_line(l_file,2);
						UTL_FILE.fclose (l_file);
						
						
		END pr_depopulate_phone_archive_tabs;



--==========================================================================================================================--  
--==========================================================================================================================--  
--==========================================================================================================================--  
--=======================================================================================================--  

END pkg_custphone_archivepurge_p;
/


